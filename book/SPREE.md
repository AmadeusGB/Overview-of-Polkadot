# 附录A   
# A.1 SPREE  
&emsp;&emsp;SPREE（Shared Protected Runtime Execution Enclaves）是一种让平行链拥有共享代码的方式，并且沙盒化代码的执行和状态。从平行链A的角度来看，它能在多大程度上信任平行链 B？Polkadot的共享安全保证了B的代码的正确执行，且保证对B代码的执行安全性与执行A代码的安全性的一样高。然而，如果我们不知道B代码本身（即使知道），B的治理机制也可以改变其代码，而我们不信任这个改变。如果要改变这种情况，我们就需要知道B的部分代码，且对这部分代码不会被B的治理机制左右，那么这部分代码可以向A发送消息，如此便知B代码的正确执行会对这些消息产生怎样的作用，所以共享安全给我们提供了我们需要的保证。  
&emsp;&emsp;SPREE模块是放置在中继链中的一段代码，平行链可以选择加入。这段代码是该链状态转换验证功能（STVF）的一部分。SPREE模块的执行和状态被沙盒化，与STVF的其他执行分离。远程链上的SPREE模块可以被XCMP寻址。平行链能收到的信息由其SPREE模块决定（这对于想要使用任何SPREE模块的链来说，这是一个内生强制执行）。  
&emsp;&emsp;我们期望XCMP发送的大多数消息将从一个链上的SPREE模块发送到另一个链上的同一SPREE模块。当SPREE模块被升级时，涉及到将更新的代码上传到中继链，并安排一个更新的区块号，它将在所有平行链的下一个区块上进行更新。这样做是为了保证一个版本的SPREE模块在一个链上向另一个链上的相同模块发送的消息时，消息永远不被过去的版本SPREE收到。因此这些被传送的消息的格式，既不需要向前兼容，也不需要取参考其它标准。  
&emsp;&emsp;举个例子，从SPREE得到的安全保证，如果A有一个原生A Token，我们希望确保平行链 B不能铸造这个Token。这一点可以通过A在A的状态下为B保留一个账户来达到。但是，当B的账户想要发送一些A Token给第三个平行链 C的时候，B需要通知A。A 的SPREE模块中负责Token的部分，允许Token在不需要核算的情况下进行转移。A的模块只需向B的相同模块发送一个消息，告知将Token发送到某个账户。然后，B可以Token发送给C，C也可以用同样的方式发送Token给A。模块本身将对B链上账户中的Token进行核算，Polkadot的共享安全以及模块的代码将强制执行B永远不能铸造A的Token。XCMP保证信息将被传递，SPREE保证信息将被正确编译执行，这意味着每次传输只需发送一个信息，并且是去需信任的。这一点的应用不仅试用于Token传输，也意味着信任最小化协议的设计会容易得多。  
&emsp;&emsp;SPREE的部分设计和实现还没有完全设计出来。目前这些归功于reddit用户u/Tawaren提出的SPREE的最初想法。  
